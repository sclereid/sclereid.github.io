---
layout: post
title:  "用python实现的lisp解释器"
date:   2017-06-09 08:40:20 +0800
categories: me
---

**随便写的一点笔记，算是以后留给自己看看当时都在想什么用的。由于网址刚刚移到jekyll，也算是测试一下到底能不能用，其中的内容诸位只当玩笑看就行了。**

之前由于学习julia语言接触了scheme和lisp家族，读完McCarthy的论文并阅读了一部分SICP之后就一直想弄一个lisp解释程序。对于纯粹的lisp语言（大概就是只有`label`, `lambda`, `cond`, `quote`, `eq`, `atom`, `cons`, `car`, `cdr`）而言，实现它的功能并不是特别复杂。不过当我用python尝试了之后我才意识到这可以有多么简洁。

+   首先是parse的部分。其实这都不应该算是lisp实现里的主要内容，但是由于可以太简短了我还是决定粘上来：

    ```python
    import re

    def parse(s):
        l = re.sub(r'\s+', ', ', (' '+s.lower()+' ').replace('(', '[').replace(')', ']'))[2:-2]
        return eval(re.sub(r'(?P<symbol>[\w#%\\/^*+_\|~<>?!:-]+)', lambda m : '"%s"' % m.group('symbol'), l))
    ```
    函数一共两行，第一行将圆括号换成方括号，并在空格处加上逗号，第二行为特定字符加上引号并调用python的eval函数将其转换为一个python数组。事实上这并不能解决所有的问题，但是，对于良好的编程风格，它还是能用的。

+   然后是上述7条功能的实现。LISP是**lis**t **p**rogramming的缩写，这里list我们就直接用python的list就可以了。然而它其实并不是真正意义上的链表，不过为了简洁我们忽略这些：

    ```python
    def cons(a, d):
        return (lambda *args : list(args))(a, *d)

    def car(s):
        return s[0]

    def cdr(s):
        if len(s) == 1:
            return []
        return s[1:]

    def atom(s):
        return not isinstance(s, list)

    def eq(s, t):
        return s == t
    ```

    大概不用怎么想都能写出这些。可能会有别的写法，不过意思应该差不多。
    剩下的可能就稍微麻烦一点了，关于语法结构的实现：

    1.  `label`的实现。由于`label`实际上是为一个表达式的值拟定了一个名称，所以我们不妨假设有一个字典存放这些名称和值的对应关系。大概可能是这样：
        ```python
        def label(l, d):
            d[l[1]] = eval_(l[2])
        ```

    2.  `cond`的实现。如果我们有一个用于求值的函数的话，应该一个一个地求值即可。至于求值的过程，不妨假设有一个`eval_(l, s)`函数（加下划线防止与python自带的`eval`混淆），它的功能为在环境`s`（考虑到lisp中一个名称在上下文中可能有不同的意义）中求出表达式`l`的值。
        ```python
        def cond(l, d):
            for [p, e] in cdr(l):
                if eval_(p, d):
                    return eval_(e, d)
        ```

    3. `lambda`的实现。λ演算是lisp的精髓，不过我们只要模拟替换的过程即可。我暂且先将代码放在这里：
        ```python
        class lambda_object:
            def __init__(self, l, d):
                self.dic = d
                self.li = l[1]
                self.ex = l[2]

            def __call__(self, *args):
                for i in range(len(self.li)):
                    self.dic[self.li[i]] = args[i]
                return eval_(self.ex, self.dic)
        ```

    4.  `quote` 很简单，被引号圈起什么返回什么就行了。
        ```python
        def quote(l, d):
            return l[1]
        ```

+   至此我们差不多已经把需要的所有东西都弄完了。不过，程序的入口还没写，现在补上：
    ```python
    def eval_(l, s=symbol_s):
        if atom(l):
            return symbol_s[l]
        if atom(l[0]) and l[0] in syntax_s:
            return syntax_s[l[0]](l, s)
        operator = eval_(l[0], s)
        operands = map(lambda e: eval_(e, s), l[1:])
        return operator(*operands)
    ```

    另外就是基础过程也需要一张表：
    ```python
    symbol_s = {'cons':cons, 'car':car, 'cdr':cdr, 'atom?':atom, 'eq?':eq, '#t':True, '#f':False}
    syntax_s = {'cond':cond, 'lambda':lambda_object, 'quote':quote, 'label':label}
    ```

    `eval_`的实现也不是特别复杂。如果求值的内容是一个atom，那么就返回它所代表的含义（从字典中查找）。如果是一个需要对一个S-表达式求值的话，那么就先判断表达式的是一个语法结构还是一个对过程的调用，然后分别予以处理即可。

    这时就可以看出`lambda_object`写法的方便之处了。调用lambda的时候，我们需要一个数据结构储存其中的内容。而`__call__`使得执行λ演算的时候不必区分基础的过程和复合的过程。

+   还差什么？也许有点难以置信，因为我们好像一直在依赖于假想的过程，几乎没怎么刻意实现它们一样。但是其实已经不差什么了。试一下：

    ``code = '''``
    ```scheme
    (label ff
      (lambda (s)
        (cond
          ((atom? s) s)
          (#t (ff (car s))))))
    ```
    ```
    '''
    eval_(parse(code))

    print eval_(parse("(ff (quote (((a b) c))))"))
    ```
    ⤇ a

于是要写的都写完了。加上充足的空行整个程序也不足60行，可见lisp的简洁。
